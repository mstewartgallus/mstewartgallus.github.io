{"version":3,"file":"896-3d8a20aa909fb8363424.js","mappings":"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","sources":["webpack://words-to-kick-your-teeth-out/./src/features/util/use-click.js","webpack://words-to-kick-your-teeth-out/./src/features/ui/a-client/use-prefetch.js","webpack://words-to-kick-your-teeth-out/./src/features/ui/a-client/use-hover.js","webpack://words-to-kick-your-teeth-out/./src/features/ui/a-client/index.jsx"],"sourcesContent":["import { useCallback } from \"react\";\nimport { navigate } from \"gatsby\";\n\nconst bubble = e => {\n    while (e && (e.tagName !== 'A' || !e.href)) {\n        e = e.parentElement;\n    }\n    return e;\n};\n\nexport const useClick = () => {\n    return useCallback(async e => {\n        // FIXME check if not my url\n        const { target, altKey, metaKey, shiftKey, ctrlKey, button } = e;\n        if (button !== 0) {\n            return;\n        }\n\n        if (altKey || metaKey || shiftKey || ctrlKey) {\n            return;\n        }\n\n        e.preventDefault();\n\n        const { href } = bubble(target);\n        const { pathname, search } = new URL(href, window.location);\n\n        const url = pathname + search;\n\n        await navigate(url);\n    }, []);\n};\n","import { useRef, useEffect } from \"react\";\nimport { prefetchPathname } from \"gatsby\";\n\nconst aborts = new WeakMap();\nconst urls = new WeakMap();\n\n// We need to use idle callbacks somewhwere because rather a lot of\n// links can suddenly appear when opening and closing disclosures and\n// accordions.  Otherwise we can lag animations here.\n\nconst idle = cb => {\n    if (window.requestIdleCallback) {\n        window.requestIdleCallback(cb, { timeout: 500 });\n    } else {\n        window.setTImeout(cb, 0);\n    }\n};\n\nconst prefetch = elem => {\n    const url = urls.get(elem);\n    if (!url) {\n        return;\n    }\n    const aborter = prefetchPathname(url);\n    aborts.set(elem, aborter);\n};\n\nconst abort = elem => {\n    const aborter = aborts.get(elem);\n    if (!aborter) {\n        return;\n    }\n\n    aborts.delete(elem);\n    aborter.abort();\n};\n\nconst onObserve = entry => {\n    const { target, isIntersecting, intersectionRatio } = entry;\n\n    const near = isIntersecting || intersectionRatio > 0;\n    if (near) {\n        prefetch(target);\n    } else {\n        abort(target);\n    }\n};\n\nlet prefetcher = null;\nconst getPrefetcher = () => {\n    if (prefetcher) {\n        return prefetcher;\n    }\n    if (!window) {\n        return null;\n    }\n\n    const { IntersectionObserver } = window;\n    if (!IntersectionObserver) {\n        return null;\n    }\n\n    prefetcher = new IntersectionObserver(entries => idle(async () => {\n        for (const entry of entries) {\n            queueMicrotask(() => onObserve(entry));\n        }\n    }));\n    return prefetcher;\n};\n\nconst addPrefetch = (elem, url, { signal }) => {\n    const pre = getPrefetcher();\n    if (!pre) {\n        return;\n    }\n\n    signal.addEventListener('abort', () => {\n        pre.unobserve(elem);\n        urls.delete(elem);\n    }, { passive: true });\n    urls.set(elem, url);\n    pre.observe(elem);\n};\n\n// FIXME move wrapper elsewhere\nexport const usePrefetch = url => {\n    const ref = useRef();\n    useEffect(() => {\n        const { current } = ref;\n        if (!current) {\n            return;\n        }\n\n        const abort = new AbortController();\n        const { signal } = abort;\n        addPrefetch(current, url, { signal });\n        return () => abort.abort();\n    }, [url]);\n    return ref;\n};\n","import { useRef, useEffect } from \"react\";\n\nconst idle = cb => {\n    if (window.requestIdleCallback) {\n        window.requestIdleCallback(cb, { timeout: 500 });\n    } else {\n        window.setTImeout(cb, 0);\n    }\n};\n\nconst onHover = (url, e) => {\n    idle(() => window.___loader.hovering(url));\n};\n\nexport const useHover = url => {\n    const ref = useRef();\n    useEffect(() => {\n        const { current } = ref;\n        if (!current) {\n            return;\n        }\n\n        // FIXME shouldn't bypass stuff\n        const abort = new AbortController();\n        const { signal } = abort;\n        current.addEventListener('mouseover',\n                                 e => onHover(url, e),\n                                 { passive: true, signal });\n        return () => abort.abort();\n    }, [url]);\n    return ref;\n};\n","import { forwardRef } from \"react\";\nimport { graphql, useStaticQuery } from \"gatsby\";\nimport { useClick } from \"@features/util\";\nimport { usePrefetch } from \"./use-prefetch\";\nimport { useHover } from \"./use-hover\";\n\nconst useSiteMetadataRaw = () => useStaticQuery(graphql`\nquery {\n  site {\n    siteMetadata {\n      siteUrl\n    }\n  }\n}`);\n\nconst AClient = ({children, ...props}, ref) => {\n    const metadata = useSiteMetadataRaw();\n\n    const siteUrl = metadata.site.siteMetadata.siteUrl;\n\n    const { origin, pathname, search, hash } = new URL(props.href ?? '', siteUrl);\n    const fail = !props.href || hash || origin !== siteUrl || props.target || props.download;\n    const url = pathname + search;\n\n    const prefetchRef = usePrefetch(url);\n    const hoverRef = useHover(url);\n\n    const onClick = useClick();\n\n    return <a onClick={fail ? null : onClick}\n              {...props}\n              ref={elem => {\n                  hoverRef.current = fail ? null : elem;\n                  prefetchRef.current = fail ? null : elem;\n\n                  if (ref) {\n                      ref.current = elem;\n                  }\n              }}>{children}</a>;\n};\n\nconst ARef = forwardRef(AClient);\n\nexport { ARef as AClient, ARef as default };\n"],"names":["aborts","WeakMap","urls","onObserve","entry","target","isIntersecting","intersectionRatio","elem","url","get","aborter","prefetchPathname","set","prefetch","delete","abort","prefetcher","getPrefetcher","window","IntersectionObserver","entries","idle","cb","async","queueMicrotask","requestIdleCallback","timeout","setTImeout","usePrefetch","ref","useRef","useEffect","current","AbortController","signal","addPrefetch","_ref","pre","addEventListener","unobserve","passive","observe","onHover","e","___loader","hovering","AClient","_props$href","children","props","siteUrl","useStaticQuery","site","siteMetadata","origin","pathname","search","hash","URL","href","fail","download","prefetchRef","hoverRef","useHover","onClick","useCallback","altKey","metaKey","shiftKey","ctrlKey","button","preventDefault","tagName","parentElement","bubble","location","navigate","_jsx","ARef","forwardRef"],"sourceRoot":""}